These are notes for chapter 12 of Deitel's How to Program C++

Chapter 12: Polymorphism
Goals: 
	- Understand the benefits of polymorphism
	- Understand keywoard overrides when overriding a base-class virtual function in 
	a derived class
	- Understand keyword default to autogenerate a virtual destructor
	- Understand keyword final to indicate that a base-class virtual function
	cannot be overriden
	- Determine an object's type at runtime using runtime type information (RTTI),
	dynamic_cast, tipeid and type_info
	- Understand how C++ can implement virtual functions and dynamic bindings
	- Use virtual destructors to ensure that all appropriate destructors have been run



What is polymorphism?
Before we explain what it is, let's explain what it helps us do. Polymorphism is a 
method of programming with inheritance hierarchies in such a way that we can program
in the general rather than the specific. 

With polymorphism, we can design easily extensible software. 
The only parts of a program to be altered to accommodate new classes are those that 
require direct knowledge of the new classes that you add to the hierarchy. 

Example: We create class "Tortoise" which inherits from class "Animal". The portions
of the simulation that process each Animal are the same, be it a tortoise
or animal object

Polymorphism enables on to deal in generalities and let the execution-time enrivonment concern itself
with the specifics. YOu can direct a variety of objects to behafve in manners appropriate to those
objects without even knowing their types, as long as those objects belong to the same
iunheritance hierarchy and are being accessed off a common base-class pointer or a 
common base-class reference. 

The point of polymorphism is to promote extensibility. SOftwarte writen to invoque polymorphic behavior
is written independently of the specific types of the objects to which messages are
sent.

New types of objects that can respond to existing messages can be incorporated in such a system without
modifying the base system. Only client code that instantiates new objects must be modified to accommodate new types

_________________

12.4 Virtual Functions and Virtual Destructors

A 'virtual' function allows the type of the object, not the type of the handle used
to invoke the object's member function, to determine which version of  a virtual 
funtion to invoke 






















